require('dotenv').config();
const express = require('express');
const multer = require('multer');
const cors = require('cors');
const path = require('path');
const fs = require('fs');
const ExtractorDatos = require('./index');
const PDFDocument = require('pdfkit');
const XLSX = require('xlsx');
const { Document, Packer, Paragraph, Table, TableRow, TableCell, WidthType, AlignmentType } = require('docx');
const { GoogleGenerativeAI } = require('@google/generative-ai');

const app = express();
const PORT = process.env.PORT || 3000;

// Configuraci√≥n de Google Gemini
console.log('üîë Verificando API key de Gemini...');
console.log('üîë API Key configurada:', process.env.GEMINI_API_KEY ? 'S√ç' : 'NO');
console.log('üîë API Key (primeros 10 chars):', process.env.GEMINI_API_KEY ? process.env.GEMINI_API_KEY.substring(0, 10) + '...' : 'NO CONFIGURADA');

const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY || 'demo-key');



// Middleware
app.use(cors());
app.use(express.json());
app.use(express.static('public'));

// Configurar multer para subida de archivos
const storage = multer.diskStorage({
    destination: function (req, file, cb) {
        const uploadDir = './uploads';
        if (!fs.existsSync(uploadDir)) {
            fs.mkdirSync(uploadDir);
        }
        cb(null, uploadDir);
    },
    filename: function (req, file, cb) {
        cb(null, Date.now() + '-' + file.originalname);
    }
});

const upload = multer({ 
    storage: storage,
    fileFilter: function (req, file, cb) {
        const allowedTypes = ['.pdf', '.xlsx', '.xls', '.docx', '.doc'];
        const ext = path.extname(file.originalname).toLowerCase();
        
        if (allowedTypes.includes(ext)) {
            cb(null, true);
        } else {
            cb(new Error(`Tipo de archivo no soportado: ${ext}`));
        }
    },
    limits: {
        fileSize: 10 * 1024 * 1024 // 10MB m√°ximo
    }
});

// Instancia del extractor
const extractor = new ExtractorDatos();

// Funci√≥n de extracci√≥n inteligente con Gemini
async function extractWithAI(text, requestedFields) {
    try {
        console.log('ü§ñ Iniciando extracci√≥n con Gemini Flash...');
        console.log('üìã Campos solicitados:', requestedFields);
        console.log('üìÑ Texto recibido (primeros 1000 chars):', text.substring(0, 1000));
        console.log('üìÑ Longitud del texto:', text.length);
        
        // Si el texto est√° vac√≠o, devolver error
        if (!text || text.length === 0) {
            console.log('‚ùå Error: No se pudo extraer texto del documento');
            return [];
        }
        
        // Verificar que la API key est√© configurada
        if (!process.env.GEMINI_API_KEY || process.env.GEMINI_API_KEY === 'demo-key') {
            console.log('‚ùå Error: API key de Gemini no configurada');
            return [];
        }
        
        // Verificar que la API key sea v√°lida (debe empezar con AIza)
        if (!process.env.GEMINI_API_KEY.startsWith('AIza')) {
            console.log('‚ùå Error: API key de Gemini no es v√°lida (debe empezar con AIza)');
            console.log('üîë API key actual:', process.env.GEMINI_API_KEY.substring(0, 20) + '...');
            console.log('üìù Por favor, obt√©n una API key v√°lida en: https://aistudio.google.com/');
            return [];
        }
        
        // Usar Gemini Flash para extracci√≥n inteligente
        const model = genAI.getGenerativeModel({ model: "gemini-2.0-flash" });
        
        const prompt = `
        Extrae EXACTAMENTE los siguientes campos del documento:
        ${requestedFields.join(', ')}
        
        Documento:
        ${text.substring(0, 30000)} // Usar m√°s texto para mejor precisi√≥n
        
        Responde SOLO con un JSON v√°lido en este formato:
        {
            "campos": [
                {"nombre": "nombre_del_campo", "valor": "valor_extraido"},
                {"nombre": "nombre_del_campo", "valor": "valor_extraido"}
            ]
        }
        
        Reglas CR√çTICAS Y OBLIGATORIAS:
        1. Extrae SOLO los campos solicitados
        2. Si no encuentras un campo, no lo incluyas
        3. Mant√©n el formato exacto del valor encontrado
        4. Para n√∫meros de orden, incluye SOLO valores √∫nicos (sin duplicados)
        5. Para ID de carga, incluye todos los valores encontrados (pueden repetirse)
        6. Para CANTIDADES, es OBLIGATORIO extraer CADA instancia individual:
           - Si ves "15 UND" tres veces en el documento, incluye "15 UND" tres veces
           - Si ves "200 UND" dos veces, incluye "200 UND" dos veces
           - NO agrupes cantidades iguales, incluye cada una por separado
           - Esto es esencial para capturar todas las entradas del documento
        7. Para otros campos, si hay m√∫ltiples valores diferentes, incluye todos
        8. Responde SOLO con el JSON, sin texto adicional
        
        REGLA M√ÅS IMPORTANTE: 
        - DEBES extraer TODOS los art√≠culos que encuentres en el documento
        - NO omitas ning√∫n art√≠culo, por m√°s que parezcan similares
        - Si una orden tiene 18 art√≠culos, extrae los 18 art√≠culos
        - Si una orden tiene 11 art√≠culos, extrae los 11 art√≠culos
        - NO hagas res√∫menes, extrae CADA art√≠culo individual
        
        IMPORTANTE: Para cantidades, extrae CADA entrada individual que veas en el documento, incluso si son repetidas.
        `;
        
        console.log('ü§ñ Enviando prompt a Gemini...');
        const result = await model.generateContent(prompt);
        const response = await result.response;
        const aiResponse = response.text();
        
        console.log('ü§ñ Respuesta de Gemini:', aiResponse);
        
        // Limpiar la respuesta de Gemini (remover markdown si existe)
        let cleanResponse = aiResponse;
        if (aiResponse.includes('```json')) {
            cleanResponse = aiResponse.replace(/```json\n?/g, '').replace(/```\n?/g, '');
        }
        
        // Intentar parsear la respuesta JSON
        try {
            const parsedData = JSON.parse(cleanResponse);
            if (parsedData.campos && Array.isArray(parsedData.campos)) {
                console.log(`‚úÖ Gemini extrajo ${parsedData.campos.length} campos`);
                return parsedData.campos;
            } else {
                console.log('‚ö†Ô∏è Respuesta de Gemini no tiene el formato esperado');
                return [];
            }
        } catch (parseError) {
            console.log('‚ö†Ô∏è Error parseando JSON de Gemini:', parseError.message);
            console.log('üìÑ Respuesta recibida:', aiResponse);
            console.log('üìÑ Respuesta limpia:', cleanResponse);
            return [];
        }
        
    } catch (error) {
        console.error('‚ùå Error en extracci√≥n con Gemini:', error);
        console.log('üîÑ Usando extracci√≥n manual como fallback...');
        return extractFieldsManually(text, requestedFields);
    }
}

// Funci√≥n de extracci√≥n manual como fallback
function extractFieldsManually(text, requestedFields) {
    console.log('üîç Iniciando extracci√≥n manual...');
    const results = [];
    
    requestedFields.forEach(field => {
        const fieldLower = field.toLowerCase().trim();
        console.log(`üîç Buscando campo: "${field}"`);
        
        if (fieldLower.includes('orden') || fieldLower.includes('order')) {
            // Buscar n√∫meros de orden
            const orderPatterns = [
                /CPOV-\d+/gi,
                /(?:N√∫mero de orden|Order):\s*([A-Z0-9\-]+)/gi
            ];
            
            const seenOrderNumbers = new Set();
            
            orderPatterns.forEach(pattern => {
                const matches = text.match(pattern);
                if (matches) {
                    matches.forEach(match => {
                        const cleanMatch = match.trim();
                        if (!seenOrderNumbers.has(cleanMatch)) {
                            seenOrderNumbers.add(cleanMatch);
                            results.push({ nombre: field, valor: cleanMatch });
                            console.log(`‚úÖ Encontrado orden √∫nico: ${cleanMatch}`);
                        }
                    });
                }
            });
        }
        
        if (fieldLower.includes('carga') || fieldLower.includes('load')) {
            // Buscar IDs de carga (sin eliminar duplicados)
            const loadPatterns = [
                /CG-\d+/gi,
                /(?:ID de carga|Load ID):\s*([A-Z0-9\-]+)/gi
            ];
            
            loadPatterns.forEach(pattern => {
                const matches = text.match(pattern);
                if (matches) {
                    matches.forEach(match => {
                        results.push({ nombre: field, valor: match.trim() });
                        console.log(`‚úÖ Encontrado ID de carga: ${match.trim()}`);
                    });
                }
            });
        }
        
        if (fieldLower.includes('env√≠o') || fieldLower.includes('envio') || fieldLower.includes('shipment')) {
            // Buscar IDs de env√≠o
            const shipmentPatterns = [
                /ENV-\d+/gi,
                /(?:ID de env√≠o|Shipment ID):\s*([A-Z0-9\-]+)/gi
            ];
            
            shipmentPatterns.forEach(pattern => {
                const matches = text.match(pattern);
                if (matches) {
                    matches.forEach(match => {
                        results.push({ nombre: field, valor: match.trim() });
                        console.log(`‚úÖ Encontrado ID de env√≠o: ${match.trim()}`);
                    });
                }
            });
        }
        
        if (fieldLower.includes('c√≥digo art√≠culo') || fieldLower.includes('codigo articulo') || fieldLower.includes('article code')) {
            // Buscar c√≥digos de art√≠culo (formato Pxxxx)
            const articleCodePatterns = [
                /P\d{4,}/gi,
                /(?:C√≥digo de art√≠culo|Article Code):\s*([A-Z0-9\-]+)/gi
            ];
            
            articleCodePatterns.forEach(pattern => {
                const matches = text.match(pattern);
                if (matches) {
                    matches.forEach(match => {
                        results.push({ nombre: field, valor: match.trim() });
                        console.log(`‚úÖ Encontrado c√≥digo de art√≠culo: ${match.trim()}`);
                    });
                }
            });
        }
        
        if (fieldLower.includes('nombre de art√≠culo') || fieldLower.includes('nombre de articulo') || fieldLower.includes('article name')) {
            // Buscar nombres de art√≠culos
            const articleNamePatterns = [
                /(?:Nombre de art√≠culo|Article Name):\s*([^\n]+)/gi,
                /(?:TUBOS|TUBO)\s+[A-Z\s]+/gi
            ];
            
            articleNamePatterns.forEach(pattern => {
                const matches = text.match(pattern);
                if (matches) {
                    matches.forEach(match => {
                        results.push({ nombre: field, valor: match.trim() });
                        console.log(`‚úÖ Encontrado nombre de art√≠culo: ${match.trim()}`);
                    });
                }
            });
        }
        
        if (fieldLower.includes('cantidad')) {
            // Buscar cantidades
            const quantityPatterns = [
                /\d+\s+(?:UND|UNIDADES|PCS|PIEZAS)/gi,
                /(?:Cantidad|Quantity):\s*(\d+)/gi
            ];
            
            quantityPatterns.forEach(pattern => {
                const matches = text.match(pattern);
                if (matches) {
                    matches.forEach(match => {
                        results.push({ nombre: field, valor: match.trim() });
                        console.log(`‚úÖ Encontrado cantidad: ${match.trim()}`);
                    });
                }
            });
        }
    });
    
    console.log(`üìä Total de campos encontrados manualmente: ${results.length}`);
    return results;
}





// Rutas de la API

// GET - P√°gina principal
app.get('/', (req, res) => {
    res.sendFile(path.join(__dirname, 'public', 'index.html'));
});

// POST - Extraer datos de archivos subidos
app.post('/api/extract', upload.array('files'), async (req, res) => {
    try {
        if (!req.files || req.files.length === 0) {
            return res.status(400).json({
                success: false,
                error: 'No se subieron archivos'
            });
        }

        const filePaths = req.files.map(file => file.path);
        const extractionType = req.body.extractionType || 'all';
        const specificFields = req.body.specificFields ? JSON.parse(req.body.specificFields) : [];
        
        const results = await extractor.extractFromMultipleFiles(filePaths, {
            extractionType,
            specificFields
        });
        const stats = extractor.getExtractionStats(results);

        // Limpiar archivos subidos despu√©s de procesarlos
        filePaths.forEach(filePath => {
            if (fs.existsSync(filePath)) {
                fs.unlinkSync(filePath);
            }
        });

        res.json({
            success: true,
            results: results,
            stats: stats
        });

    } catch (error) {
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

// POST - Extracci√≥n inteligente con IA
app.post('/api/extract-ai', upload.array('files'), async (req, res) => {
    try {
        if (!req.files || req.files.length === 0) {
            return res.status(400).json({
                success: false,
                error: 'No se subieron archivos'
            });
        }

        const filePaths = req.files.map(file => file.path);
        const requestedFields = req.body.fields ? JSON.parse(req.body.fields) : [];
        
        if (requestedFields.length === 0) {
            return res.status(400).json({
                success: false,
                error: 'No se especificaron campos para extraer'
            });
        }

        console.log('ü§ñ Iniciando extracci√≥n con IA para campos:', requestedFields);
        
        // Extraer texto del primer archivo
        const extractor = new ExtractorDatos();
        const textResult = await extractor.extractFromMultipleFiles(filePaths, {
            extractionType: 'all'
        });
        
        if (!textResult || textResult.length === 0) {
            return res.status(500).json({
                success: false,
                error: 'No se pudo extraer texto del documento'
            });
        }
        
        // Obtener el texto del resultado
        const firstResult = textResult[0];
        let fullText = '';
        
        if (firstResult.success && firstResult.data) {
            // Para PDF, Word, Text
            if (firstResult.data.text) {
                fullText = firstResult.data.text;
            }
            // Para Excel, convertir a texto
            else if (firstResult.data.sheets) {
                fullText = firstResult.data.sheets.map(sheet => 
                    sheet.data.map(row => row.join(' ')).join('\n')
                ).join('\n');
            }
        }
        
        console.log('üìÑ Texto extra√≠do (primeros 500 chars):', fullText.substring(0, 500));
        console.log('üìÑ Longitud total del texto:', fullText.length);
        
        // Validar que se extrajo texto
        if (!fullText || fullText.trim().length === 0) {
            return res.status(500).json({
                success: false,
                error: 'No se pudo extraer texto del documento. El archivo puede estar protegido, ser una imagen, o tener formato no est√°ndar.'
            });
        }
        
        // Extraer campos con IA
        const extractedFields = await extractWithAI(fullText, requestedFields);
        
        // Limpiar archivos subidos
        filePaths.forEach(filePath => {
            if (fs.existsSync(filePath)) {
                fs.unlinkSync(filePath);
            }
        });
        
        // Formatear resultados y eliminar duplicados de n√∫meros de orden
        const structuredData = [];
        const seenOrderNumbers = new Set();
        
        extractedFields.forEach(field => {
            const isOrderNumber = field.nombre.toLowerCase().includes('n√∫mero de orden') || 
                                 field.nombre.toLowerCase().includes('numero de orden') ||
                                 field.nombre.toLowerCase().includes('order number');
            
            if (isOrderNumber) {
                // Para n√∫meros de orden, verificar duplicados
                if (!seenOrderNumbers.has(field.valor)) {
                    seenOrderNumbers.add(field.valor);
                    structuredData.push({
                        label: field.nombre,
                        value: field.valor
                    });
                }
            } else {
                // Para otras categor√≠as, agregar normalmente
                structuredData.push({
                    label: field.nombre,
                    value: field.valor
                });
            }
        });
        
        res.json({
            success: true,
            results: [{
                fileName: req.files[0].originalname,
                structuredData: structuredData,
                fullText: fullText.substring(0, 1000) // Limitar para respuesta
            }],
            stats: {
                totalFiles: 1,
                totalFields: extractedFields.length,
                extractionMethod: 'AI'
            }
        });

    } catch (error) {
        console.error('‚ùå Error en extracci√≥n con IA:', error);
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

// POST - Exportar resultados a diferentes formatos
app.post('/api/export', async (req, res) => {
    try {
        const { fileName, format, structuredData, fullText } = req.body;
        
        if (!fileName || !format || !structuredData) {
            return res.status(400).json({
                success: false,
                error: 'Datos incompletos para la exportaci√≥n'
            });
        }

        let buffer;
        const baseFileName = fileName.replace(/\.[^/.]+$/, '');

        switch (format) {
            case 'pdf':
                buffer = await generatePDF(baseFileName, structuredData, fullText);
                res.setHeader('Content-Type', 'application/pdf');
                res.setHeader('Content-Disposition', `attachment; filename="${baseFileName}_resultados.pdf"`);
                break;
                
            case 'word':
                buffer = await generateWord(baseFileName, structuredData, fullText);
                res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document');
                res.setHeader('Content-Disposition', `attachment; filename="${baseFileName}_resultados.docx"`);
                break;
                
            case 'excel':
                buffer = await generateExcel(baseFileName, structuredData, fullText);
                res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
                res.setHeader('Content-Disposition', `attachment; filename="${baseFileName}_resultados.xlsx"`);
                break;
                
            default:
                return res.status(400).json({
                    success: false,
                    error: 'Formato no soportado'
                });
        }

        res.send(buffer);

    } catch (error) {
        console.error('Error en exportaci√≥n:', error);
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

// GET - Obtener estad√≠sticas del servidor
app.get('/api/stats', (req, res) => {
    res.json({
        server: 'Extractor de Datos API',
        version: '1.0.0',
        supportedFormats: ['.pdf', '.xlsx', '.xls', '.docx', '.doc'],
        uptime: process.uptime()
    });
});

// GET - Probar con archivo espec√≠fico
app.get('/api/test/:filename', async (req, res) => {
    try {
        const filename = req.params.filename;
        const filePath = path.join('./ejemplos', filename);
        
        if (!fs.existsSync(filePath)) {
            return res.status(404).json({
                success: false,
                error: 'Archivo no encontrado'
            });
        }

        const result = await extractor.extractFromFile(filePath);
        res.json({
            success: true,
            result: result
        });

    } catch (error) {
        res.status(500).json({
            success: false,
            error: error.message
        });
    }
});

// Manejo de errores
app.use((error, req, res, next) => {
    if (error instanceof multer.MulterError) {
        if (error.code === 'LIMIT_FILE_SIZE') {
            return res.status(400).json({
                success: false,
                error: 'Archivo demasiado grande (m√°ximo 10MB)'
            });
        }
    }
    
    res.status(500).json({
        success: false,
        error: error.message
    });
});

// Funciones para generar archivos de exportaci√≥n

// Generar PDF
async function generatePDF(fileName, structuredData, fullText) {
    return new Promise((resolve, reject) => {
        try {
            const doc = new PDFDocument();
            const chunks = [];
            
            doc.on('data', chunk => chunks.push(chunk));
            doc.on('end', () => resolve(Buffer.concat(chunks)));
            
            // T√≠tulo simple
            doc.fontSize(16).text('N√∫meros de Orden Extra√≠dos', { align: 'center' });
            doc.moveDown();
            doc.fontSize(12).text(`Archivo: ${fileName}`, { align: 'center' });
            doc.moveDown(2);
            
            // Agrupar datos por categor√≠a
            const groupedData = {};
            if (structuredData && structuredData.length > 0) {
                structuredData.forEach(item => {
                    if (!groupedData[item.label]) {
                        groupedData[item.label] = [];
                    }
                    groupedData[item.label].push(item.value);
                });
            }

            // Crear tabla para cada categor√≠a
            Object.keys(groupedData).forEach(category => {
                const values = groupedData[category];
                
                // Nueva p√°gina para cada categor√≠a
                if (doc.y > doc.page.height - 100) {
                    doc.addPage();
                }
                
                // T√≠tulo de la categor√≠a
                doc.fontSize(12).text(`${category}:`, { underline: true });
                doc.moveDown();
                
                // Listar los valores
                values.forEach((value, index) => {
                    // Nueva p√°gina si es necesario
                    if (doc.y > doc.page.height - 100) {
                        doc.addPage();
                    }
                    
                    doc.fontSize(10).text(`${index + 1}. ${value}`, {
                        continued: false,
                        indent: 20
                    });
                });
                
                doc.moveDown(2);
            });
            
            // No mostrar resumen ni texto completo cuando solo se pidieron campos espec√≠ficos
            if (structuredData && structuredData.length > 0) {
                // El texto completo y resumen se omiten intencionalmente
                doc.end();
                return;
            }
            
            doc.end();
        } catch (error) {
            reject(error);
        }
    });
}

// Generar Word
async function generateWord(fileName, structuredData, fullText) {
    // Agrupar datos por categor√≠a
    const groupedData = {};
    if (structuredData && structuredData.length > 0) {
        structuredData.forEach(item => {
            if (!groupedData[item.label]) {
                groupedData[item.label] = [];
            }
            groupedData[item.label].push(item.value);
        });
    }
    
    const children = [
        new Paragraph({
            text: 'Resultados de Extracci√≥n de Datos',
            heading: 'Heading1',
            alignment: AlignmentType.CENTER
        }),
        new Paragraph({
            text: `Archivo: ${fileName}`,
            alignment: AlignmentType.CENTER
        }),
        new Paragraph({
            text: `Fecha: ${new Date().toLocaleString()}`,
            alignment: AlignmentType.CENTER
        }),
        new Paragraph({ text: '' }),
        new Paragraph({ text: '' })
    ];
    
    // Agregar secciones por categor√≠a
    Object.keys(groupedData).forEach(category => {
        const categoryData = groupedData[category];
        
        children.push(
            new Paragraph({
                text: `${category} (${categoryData.length} elementos):`,
                heading: 'Heading2'
            }),
            new Paragraph({ text: '' })
        );
        
        // Tabla para cada categor√≠a
        const tableRows = [
            new TableRow({
                children: [
                    new TableCell({
                        children: [new Paragraph({ text: '#', bold: true })],
                        width: { size: 15, type: WidthType.PERCENTAGE }
                    }),
                    new TableCell({
                        children: [new Paragraph({ text: 'Valor', bold: true })],
                        width: { size: 85, type: WidthType.PERCENTAGE }
                    })
                ]
            })
        ];
        
        categoryData.forEach((value, index) => {
            tableRows.push(
                new TableRow({
                    children: [
                        new TableCell({
                            children: [new Paragraph({ text: (index + 1).toString() })]
                        }),
                        new TableCell({
                            children: [new Paragraph({ text: value })]
                        })
                    ]
                })
            );
        });
        
        children.push(
            new Table({
                width: { size: 100, type: WidthType.PERCENTAGE },
                rows: tableRows
            }),
            new Paragraph({ text: '' }),
            new Paragraph({ text: '' })
        );
    });
    
    const doc = new Document({
        sections: [{
            properties: {},
            children: children
        }]
    });
    
    return await Packer.toBuffer(doc);
}

// Generar Excel
async function generateExcel(fileName, structuredData, fullText) {
    console.log('üìä Generando Excel con datos:', JSON.stringify(structuredData, null, 2));
    const workbook = XLSX.utils.book_new();
    
    // Agrupar datos por categor√≠a y eliminar duplicados
    const groupedData = {};
    if (structuredData && structuredData.length > 0) {
        structuredData.forEach(item => {
            // Verificar si el item tiene la estructura correcta
            const label = item.label || item.nombre || '';
            const value = item.value || item.valor || '';
            
            if (!groupedData[label]) {
                groupedData[label] = [];
            }
            
            // Para n√∫meros de orden, verificar si ya existe antes de agregar
            if (label.toLowerCase().includes('n√∫mero de orden') || 
                label.toLowerCase().includes('numero de orden') ||
                label.toLowerCase().includes('order number')) {
                // Solo agregar si no existe ya
                if (!groupedData[label].includes(value)) {
                    groupedData[label].push(value);
                }
            } else {
                // Para otras categor√≠as (incluyendo ID de carga), agregar normalmente
                groupedData[label].push(value);
            }
        });
    }
    
    // Crear tabla horizontal con columnas separadas
    const allData = [];
    
        // Crear registros basados en la estructura de datos extra√≠dos
    const records = [];
    const loadId = groupedData['ID de carga']?.[0] || '';
    
    if (structuredData && structuredData.length > 0) {
        // Procesar los datos secuencialmente para mantener las relaciones exactas
        let currentOrder = '';
        let currentShipment = '';
        let currentArticleCode = '';
        let currentArticleName = '';
        let currentQuantities = [];
        
        for (let i = 0; i < structuredData.length; i++) {
            const item = structuredData[i];
            const label = item.label || item.nombre || '';
            const value = item.value || item.valor || '';
            
            if (label.toLowerCase().includes('n√∫mero de orden') || label.toLowerCase().includes('numero de orden')) {
                // Si tenemos datos acumulados, crear registros
                if (currentOrder && currentShipment && currentArticleCode) {
                    if (currentQuantities.length === 0) {
                        records.push({
                            loadId: loadId,
                            shipmentId: currentShipment,
                            orderNumber: currentOrder,
                            articleCode: currentArticleCode,
                            articleName: currentArticleName,
                            quantity: ''
                        });
                    } else {
                        // Crear un registro por cada cantidad
                        for (const quantity of currentQuantities) {
                            records.push({
                                loadId: loadId,
                                shipmentId: currentShipment,
                                orderNumber: currentOrder,
                                articleCode: currentArticleCode,
                                articleName: currentArticleName,
                                quantity: quantity
                            });
                        }
                    }
                }
                
                // Iniciar nuevo registro
                currentOrder = value;
                currentShipment = '';
                currentArticleCode = '';
                currentArticleName = '';
                currentQuantities = [];
                
            } else if (label.toLowerCase().includes('id del env√≠o') || label.toLowerCase().includes('id del envio')) {
                currentShipment = value;
            } else if (label.toLowerCase().includes('c√≥digo art√≠culo') || label.toLowerCase().includes('codigo articulo')) {
                // Si encontramos un nuevo c√≥digo de art√≠culo, procesar el registro anterior
                if (currentOrder && currentShipment && currentArticleCode) {
                    if (currentQuantities.length === 0) {
                        records.push({
                            loadId: loadId,
                            shipmentId: currentShipment,
                            orderNumber: currentOrder,
                            articleCode: currentArticleCode,
                            articleName: currentArticleName,
                            quantity: ''
                        });
                    } else {
                        // Crear un registro por cada cantidad
                        for (const quantity of currentQuantities) {
                            records.push({
                                loadId: loadId,
                                shipmentId: currentShipment,
                                orderNumber: currentOrder,
                                articleCode: currentArticleCode,
                                articleName: currentArticleName,
                                quantity: quantity
                            });
                        }
                    }
                }
                
                // Iniciar nuevo art√≠culo
                currentArticleCode = value;
                currentArticleName = '';
                currentQuantities = [];
                
            } else if (label.toLowerCase().includes('nombre de art√≠culo') || label.toLowerCase().includes('nombre de articulo')) {
                currentArticleName = value;
            } else if (label.toLowerCase().includes('cantidad')) {
                currentQuantities.push(value);
            }
        }
        
        // Procesar el √∫ltimo registro
        if (currentOrder && currentShipment && currentArticleCode) {
            if (currentQuantities.length === 0) {
                records.push({
                    loadId: loadId,
                    shipmentId: currentShipment,
                    orderNumber: currentOrder,
                    articleCode: currentArticleCode,
                    articleName: currentArticleName,
                    quantity: ''
                });
            } else {
                // Crear un registro por cada cantidad
                for (const quantity of currentQuantities) {
                    records.push({
                        loadId: loadId,
                        shipmentId: currentShipment,
                        orderNumber: currentOrder,
                        articleCode: currentArticleCode,
                        articleName: currentArticleName,
                        quantity: quantity
                    });
                }
            }
        }
    }
    
    console.log('üìä Registros agrupados:', records);
    
    // Crear encabezados
    const headers = ['ID de carga', 'ID del env√≠o', 'N√∫mero de orden', 'C√≥digo art√≠culo', 'Nombre de art√≠culo', 'Cantidad'];
    allData.push(headers);
    
    // Crear filas de datos
    if (records.length > 0) {
        records.forEach(record => {
            const row = [
                record.loadId,
                record.shipmentId,
                record.orderNumber,
                record.articleCode,
                record.articleName,
                record.quantity
            ];
            allData.push(row);
        });
    } else {
        // Si no hay registros, agregar una fila vac√≠a
        allData.push(['', '', '', '', '', '']);
    }
    
    console.log('üìä Tabla final:', allData);
    
    const mainWorksheet = XLSX.utils.aoa_to_sheet(allData);
    
    // Aplicar estilos b√°sicos con anchos fijos para las 6 columnas
    mainWorksheet['!cols'] = [
        { width: 20 },  // ID de carga
        { width: 20 },  // ID del env√≠o
        { width: 25 },  // N√∫mero de orden
        { width: 15 },  // C√≥digo art√≠culo
        { width: 50 },  // Nombre de art√≠culo
        { width: 15 }   // Cantidad
    ];
    
    XLSX.utils.book_append_sheet(workbook, mainWorksheet, 'Datos Extra√≠dos');
    
    // Hoja de resumen
    const summaryData = [
        ['RESUMEN DE EXTRACCI√ìN'],
        [''],
        ['Categor√≠a', 'Cantidad'],
        ...Object.keys(groupedData).map(category => [
            category, 
            groupedData[category].length
        ])
    ];
    
    const summaryWorksheet = XLSX.utils.aoa_to_sheet(summaryData);
    XLSX.utils.book_append_sheet(workbook, summaryWorksheet, 'Resumen');
    

    
    return XLSX.write(workbook, { type: 'buffer', bookType: 'xlsx' });
}

// Iniciar servidor
app.listen(PORT, () => {
    console.log(`üöÄ Servidor iniciado en http://localhost:${PORT}`);
    console.log(`üìä API disponible en http://localhost:${PORT}/api/extract`);
    console.log(`üìà Estad√≠sticas en http://localhost:${PORT}/api/stats`);
});

module.exports = app; 